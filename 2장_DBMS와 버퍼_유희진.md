> 2장에서는 DBMS의 버퍼 매니저가 어떤 기능을 수행하는지 알아본다.
> 

## 공짜 밥은 존재할까?

### 기억 장치의 분류 계층

- 1차 기억 장치: 레지스터, 메모리 등
- 2차 기억 장치: HDD, CD, DVD
- 3차 기억 장치: 테이프 등

### 기억 장치의 특징

- 1차 기억 장치로 갈수록 접근 속도가 빠르고 기억 비용이 높다.
    - cpu와 가까울수록 빠르고 비싸다.
- 3차 기억 장치로 갈수록 접근 속도가 느리고 기억 비용이 낮다.
    - 반대로 cpu에서 멀어질수록 속도가 느리고 저렴하다.

![KakaoTalk_Photo_2023-09-17-15-07-50](https://github.com/yu-heejin/sql-levelup/assets/96467030/12ac18a5-ff30-46c5-b97f-33348deb997b)


- 일반적으로 기억장치는 기억 비용에 따라 1차부터 3차까지의 계층으로 분류한다.
    - 기억 비용이란 간단하게 ‘데이터를 저장하는데 소모되는 비용’을 의미한다.
- 피라미드 아래 면적이 큰 이유는 ‘같은 비용으로 저장할 수 있는 데이터 용량이 많다’라는 것을 의미한다.
- 많은 데이터를 영속적으로 저장하려면 속도를 잃고, 속도를 얻고자 하면 많은 데이터를 영속적으로 저장하기 힘들다는 트레이드 오프가 발생한다. → **‘공짜밥은 없다’, 저장소와 관련되어 나타나는 첫번째 트레이드 오프**

## DBMS와 기억장치의 관계

- DBMS는 데이터 저장을 목적으로 하는 미들웨어이기 때문에 기억 장치와 떨어뜨릴 수 없는 관계이다.

### DBMS가 사용하는 대표적인 기억 장치

- 하드 디스크(HDD)
    - DBMS가 데이터를 저장하는 매체는 대부분 HDD이다. (용량, 비용, 성능 관점에서 선택)
    - 하드 디스크는 기억장치 계층에서 한가운데에 있는 2차 기억장치로 분류된다. (장점도 단점도 없는 무난한 매체)
    - 데이터베이스는 대부분의 시스템에서 범용적으로 사용되는 미들웨어이기 때문에 어떤 상황에서도 평균적인 수치를 가지는 매체를 선택하는 것이 자연스럽다.
    - 그러나 DBMS가 데이터를 디스크 이외의 장소에 저장하지 않는다는 뜻은 아니다. 오히려 일반적인 DBMS는 항상 디스크 이외의 장소에도 데이터를 올려놓는데, 이 곳이 바로 1차 계층의 기억장치 메모리이다.
- 메모리
    - 메모리는 디스크에 비해 기억 비용이 상당히 비싸기 때문에 하드웨어 한 대에 탑재할 수 있는 양이 크지 않다.
    - 따라서 규모 있는 상용 시스템의 데이터베이스 내부 데이터를 모두 메모리에 올리는 것은 불가능하다.
- 버퍼를 활용한 속도 향상
    - DBMS가 일부라도 데이터를 메모리에 올리는 것은 성능 향상 때문이다.
        - SQL 구문의 실행 속도를 빠르게 만들기 위함이다.
    - 메모리는 가장 빠른 1차 기억 장치이기 때문에 **자주 접근하는 데이터를 메모리 위에 올리면 같은 SQL 구문을 실행한다고 해도 디스크에서 데이터를 가져올 필요 없이 곧바로 메모리에서 읽어 빠르게 데이터를 검색**할 수 있다. (일종의 캐시와 비슷하다.)
    - 디스크 접근을 줄일 수 있다면 굉장히 큰 폭의 성능 향상이 가능한데, 이는 **일반적인 SQL 구문의 실행 시간 대부분을 저장소 I/O에 사용하기 때문이다.**
    - 이렇듯 **성능 향상을 목적으로 데이터를 저장하는 메모리를 버퍼(Buffer) 또는 캐시(Cache)라고 부른다.**
        - 버퍼는 ‘완충제’의 의미를 가지는데, 사용자와 저장소 사이에서 SQL 구문의 디스크 접근을 줄여주는 역할을 한다.
        - 캐시 역시 사용자와 저장소 사이에서 데이터 전송 지연을 완화시켜준다.
        - 따라서 이 책에서는 버퍼와 캐시를 거의 같은 용어로 사용한다.
    - **고속 접근이 가능한 버퍼에 데이터를 어떻게, 어느 정도의 기간 동안 올릴지를 관리하는 것이 DBMS의 버퍼 매니저**이다.
    - 버퍼 매니저는 성능에 굉장히 중요한 영향을 끼친다.
    

## 메모리 위에 있는 두 개의 버퍼

- DBMS가 데이터를 유지하기 위해 사용하는 메모리는 다음과 같다.
    - 데이터 캐시
        - 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역
    - 로그 버퍼
        - 로그 버퍼는 갱신 처리(CUD)와 관련이 있는데, DBMS는 갱신과 관련된 SQL 구문을 사용자에게 받으면, 곧바로 저장소에 있는 데이터를 변경하지 않고 로그 버퍼 위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다.
        - CUD → 로그 버퍼에 기록 → commit → 저장소에 저장
- 대부분의 DBMS는 이러한 두 개의 역할을 하는 메모리 영역을 가지고 있다.
    - 이러한 버퍼는 사용자가 용도에 따라 크기를 변경하는 것이 가능하다.
- 아래 이미지는 데이터베이스별 메모리 크기이다.

![KakaoTalk_Photo_2023-09-17-15-07-15](https://github.com/yu-heejin/sql-levelup/assets/96467030/f39f46d7-a728-4c90-bcb9-56ff937895e1)


### 데이터 캐시

- 데이터 캐시는 디스크에 있는 데이터의 일부를 메모리에 유지하기 위해 사용하는 메모리 영역이다.
- 만약 우리가 실행한 `SELECT` 구문에서 선택하고 싶은 데이터가 운 좋게 모두 이러한 데이터 캐시에 있다면, 디스크와 같은 저속 저장소에 접근하지 않고 처리가 수행된다.
- 반대로 운 나쁘게 버퍼에서 데이터를 찾을 수 없다면 저속 저장소까지 데이터를 가지러 가야한다. → 속도 저하

### 로그 버퍼

- 로그 버퍼는 갱신 처리(`INSERT`, `DELETE`, `UPDATE`, `MERGE`)와 관련있다.
- DBMS는 갱신과 관련된 SQL 구문을 바로 변경하지 않고, **일단 로그 버퍼위에 변경 정보를 보내고 이후 디스크에 변경을 수행한다. (Write Ahead Logging, WAL)**
    
    ![KakaoTalk_Photo_2023-09-17-15-06-31](https://github.com/yu-heejin/sql-levelup/assets/96467030/d7e3e882-576d-4632-a654-b328ca00066e)

    
    - 이처럼 데이터베이스의 갱신 처리는 SQL 구문 실행 시점과 저장소에 갱신하는 시점에 차이가 있는 비동기 처리이다.
- DBMS가 이러한 시점 차이를 두는 이유는 성능을 높이기 위해서이다.
    - 저장소는 검색뿐만 아니라 갱신 시에도 상당한 시간이 소모되기 때문에, 저장소 변경이 끝날 때까지 기다리면 사용자는 장시간 대기해야하는 문제가 발생한다.
    - 따라서 한 번 메모리에 갱신 정보를 받은 시점에서 사용자에게는 해당 SQL 구문이 끝났다고 통지하고, 내부적으로 관련된 처리를 계속 수행한다.

→ 결국 DBMS는 저장소의 느림을 어떻게 보완할 것인가에 대해 계속 고민해온 미들웨어라고 할 수 있다.

## 메모리의 성질이 초래하는 트레이드 오프

### 휘발성

- 메모리에는 데이터의 영속성이 없다.
- 하드웨어의 전원을 꺼버리면 메모리 위에 올라가 있는 모든 데이터가 사라져버리는데, 이를 휘발성이라고 한다.
- DBMS를 껐다가 다시 켜면 버퍼 위의 모든 데이터가 사라진다.
    - DBMS에 어떤 장애가 발생해 프로세스 다운이 일어나면 메모리 위에 있는 모든 데이터가 날아간다.
    - 결국 미래에 메모리 가격이 저렴해진다고 할지라도 영속성이 없는 이상 기능적으로 디스크를 완전히 대체하는 것은 불가능하다.

### 휘발성의 문제점

- 휘발성의 가장 큰 문제점은 장애가 발생했을 때 메모리에 있던 데이터가 모두 사라져버려 데이터의 부정합을 발생시키는 것이다.
    - 데이터의 부정합은 데이터가 연결되어있는 메모리 상에서 변경되는 경우 관련된 데이터들이 일괄적으로 값을 일치화시키는 과정에서 데이터의 값이 다른 경우를 말한다. (https://drehzr.tistory.com/917)
- 데이터 캐시라면 장애로 인해 메모리 위의 데이터가 사라져버려도 원본 데이터는 디스크 위에 남아있으므로 아무 문제가 없다.
- 그러나 **로그 버퍼 위에 존재하는 데이터가 디스크 위의 로그 파일에 반영되기 전에 장애가 발생해서 사라져버리면 복구가 불가능**하다.
    - 이는 사용자가 수행했던 갱신 정보가 사라진다는 의미이다.
- 로그 파일에 전달된 갱신 정보가 DBMS가 다운될 때 사라지는 문제를 예방하고자 DBMS는 커밋 시점에 반드시 갱신 정보를 로그 파일에 씀으로써, 장애가 발생해도 정합성을 유지하도록 한다.
    - **커밋(Commit)이란 갱신 처리를 확정**하는 것인데, DBMS는 커밋된 데이터를 영속화한다.
    - 커밋 시에는 반드시 디스크에 동기 접근이 일어나는데, 이 과정에서 지연이 발생할 가능성이 있다. → 트레이드오프 (디스크에 동기 처리를 한다면 데이터 정합성은 높아지지만 성능이 떨어진다.)

## 시스템 특성에 따른 트레이드 오프

### 데이터 캐시와 로그 버퍼의 크기

- 데이터 캐시에 비해 DBMS의 로그 버퍼 초깃값은 상당히 작다.
- 데이터페이스가 2개의 버퍼에 대해 극단적으로 비대칭적인 크기를 할당한 데에는 이유가 있는데, 이는 **데이터베이스가 기본적으로 검색(SELECT)을 메인으로 처리한다고 가정하기 때문이다.**
    - 검색의 경우 검색 대상 레코드가 수백만에서 수천만 건에 달하는 경우도 많은데, 갱신처리를 할 때는 갱신 대상이 검색 대상 레코드에 비해 적다.
    - 따라서 갱신 시 비싼 메모리를 많이 사용하기 보다는 자주 검색하는 데이터를 캐시에 올려놓는 것이 좋다.
        
        ![KakaoTalk_Photo_2023-09-17-15-05-41](https://github.com/yu-heejin/sql-levelup/assets/96467030/6809507b-2eac-42ed-ad18-35978d9ad373)

        
- 실제 DBMS는 물리 메모리에 여유가 있다면 데이터 캐시를 되도록 많이 할당할 것을 추천한다.
    - 서버가 데이터베이스 전용이라면 물리 메모리의 80%를 버퍼 풀로 할당해도 괜찮다.
- 만약 내가 만드는 시스템이 검색에 비해 갱신이 많다면, 초기 설정을 그대로 사용해서는 성능이 제대로 나오지 않을 수 있다. → 로그 버퍼의 크기를 늘려주는 튜닝 고려

### 검색과 갱신 중에서 중요한 것

- 검색과 갱신 중 어떤 것이 우선사 되어야하는지 판단해야한다.
- 최근 DBMS는 리소스를 자동으로 조정하고 이를 사용해 메모리 할당을 스스로 조정하기도 한다.
    - 그러나 중요한 리소스 배분이 필요한 상황에서 아무 생각 없이 자동 설정에 의지하는 일은 위험하다.
- 데이터베이스가 어떠한 생각에 기반을 둬서 리소스를 배분하고 있는지를 이해하는 것이 중요하다.
    - 로그 버퍼가 크게 잡혀있다 → 갱신 처리와 관련해 큰 부하가 걸릴 것을 고려한 설계
    - 데이터 캐시가 크게 잡혀있다 → 검색 처리와 관련된 처리가 중심

## 추가적인 메모리 영역 ‘워킹 메모리’

- DBMS는 2개의 버퍼 이외에도 일반적으로 메모리 영역을 하나 더 가지고 있는데, 이는 **정렬 또는 해시 관련 처리에 사용되는 작업용 영역으로 워킹 메모리(working memory)라고 부른다.**
- 정렬은 `ORDER BY`, 집합 연산, 윈도우 함수 등의 기능을 사용할 때 실행되며, 해시는 주로 테이블의 결합에서 해시 결합(Hash Join)이 사용되는 때 실행된다.
    - Hash Join은 조인될 두 테이블 중 하나를 해시 테이블로 선정하여 조인될 테이블의 조인 키 값을 해시 알고리즘으로 비교하여 매치되는 결과값을 얻는 방식이다. (https://coding-factory.tistory.com/758)
- 이 메모리 영역의 이름과 관리 방법은 DBMS마다 다르다.
    
    
    | DBMS | 명칭 | 매개변수 | 기본값 |
    | --- | --- | --- | --- |
    | Oracle (11g R2) | PGA(Program Global Area) | PGA_AGGREGATE_TARGET | 10MB 또는 SGA 크기의 20% 중에 큰 것 |
    | PostgreSQL (9.3) | 워크 버퍼 | work_mem | 8MB |
    | MySQL (5.7) | 정렬 버퍼 | sort_buffer_size | 256KB |
- 이 작업용 메모리 영역은 SQL에서 정렬 또는 해시가 필요한 때 사용되고, 종료되면 해제되는 임시 영역으로, 일반적으로는 데이터 캐시와 로그 버퍼와는 다른 영역으로 관리되는 경우가 많다.
- 해당 영역이 성능적으로 중요한 이유는 만약 이 영역이 다루려는 데이터양보다 작아 부족해지는 경우가 생기면 대부분의 DBMS가 영구 저장소를 사용하기 때문이다.
    
    ![KakaoTalk_Photo_2023-09-17-15-03-43](https://github.com/yu-heejin/sql-levelup/assets/96467030/31230aee-5baf-470a-8fb9-e38c367d3cee)

    
    - 이는 OS 동작에서 말하는 스왑(swap)과 같은 것이다. (하드 디스크 내에 스왑 영역 존재)
- 많은 DBMS는 워킹 메모리가 부족할 때 사용하는 임시적인 영역을 가지고 있다.
    - Oracle: 임시 테이블 스페이스(TEMP Tablespace)
    - Microsoft SQL Sever(MSSQL): TEMPDB
    - PostgreSQL: 일시 영역(pgsql_tmp)
    
    → 이러한 일시 영역들은 저장소 위에 있기 때문에 당연히 접근 속도가 느리다.
    

### 저장소가 부족해지면?

- 저장소는 메모리에 비해 굉장히 느리다.
    - 메모리에서 작동하고 있을 때는 빠르게 움직이다가, 메모리가 부족해지는 순간 갑자기 느려지는 순간적인 변화가 일어난다.
- 이 영역은 여러 개의 SQL 구문들이 공유해서 사용하므로, 하나의 SQL 구문을 실행하고 있을 때는 메모리에 잘 들어가지만, 여러 개의 SQL 구문을 동시에 실행하면 메모리가 넘치는 경우가 있다.
    - 따라서 **이러한 상황을 재현하는 검사(부하 검사)를 실시하지 않으면 메모리 부족 현상이 일어날지 판별하기 어렵다.**
    - 하나가 있을 때의 성질뿐만 아니라 여러 개가 있을 때의 성질도 주의해야 한다는 것은 컨트롤하기 힘든 성능 문제이다.
